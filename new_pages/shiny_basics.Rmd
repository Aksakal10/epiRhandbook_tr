
# Shiny and dashboards { }  

One of the largest drawbacks of `R` is its usability for people who are new to or have no experience with programming languages. While these skills are very valuable, most people will find that this represents a barrier to sharing analyses, especially in multidisciplinary environments. It requires some work to maintain an `R` installation, and not everyone will be comfortable running shared code, even if it's well documented and easy to read. This is *especially* true when users have to change parameters of code! For this reason dashboards are often a great way to share results from analyses with others without having to interface with code itself. 

R based dashboards are also advantageous in that they centralise how code is run - when the same code is run on different machines, often people will have to deal with differing file paths, different R versions, and different package installations. For this reason, dashboards are a great way to share code with others in a user friendly way!

Despite this, making dashboards in `R` requires a relatively advanced knowledge of the language. For this reason, it is recommended that someone learning dashboards has good knowledge of data transformation and visualisation, and is comfortable debugging code, and writing functions. Working with dashboards is not intuitive when you're starting, and is difficult to understand at times, but is a great skill to learn and gets much easier with practice!

This section will give a short overview of how you can use `R` to make dashboards, primarily by using the excellent `shiny` package, and its extensions.

<!-- ======================================================= -->
## The structure of a shiny app {  }

### Basic file structures
To understand `shiny`, we first need to understand the file structure of an app works! We should make a brand new directory before we start. This can actually be made easier by choosing _New project_ in _Rstudio_, and choosing _Shiny Web Application_. This will create the basic structure of a shiny app for you.

Lets also install shiny before we go any further:

```{r, eval = FALSE}
install.packages("shiny")
```

When opening this project, you'll notice there is a `.R` file already present called _app.R_. It is *essential* that we either have one of two basic file structures in our file structure:

1. A file called _app.R_
2. Two files called _ui.R_ and _server.R_

```{r, eval = FALSE}

# an example of app.R

ui <- fluidPage(

    # Application title
    titlePanel("My app"),

    # Sidebar with a slider input widget
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # Show a plot 
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# Run the application 
shinyApp(ui = ui, server = server)


```


If you open this file, you'll notice that two different objects are defined one called `ui` and another called `server`. These objects *must* be defined in *every* shiny app and are central to the structure of the app itself! The only difference between the two structures above is that in structure 1, both `ui` and `server` are defined in one file, while they are defined in separate files in structure 2. We can also (and we should if we have a larger app) have other .R files in our structure that we can `source()` into our app, but we need these core files at all times.



### The server and the ui

We next need to understand what the server and ui objects actually _do_. Put simply, these are two objects that are interacting with each other whenever the user interacts with the shiny app.

The UI element of a shiny app is, on a basic level, R code that creates an HTML interface. This means that everything that is *displayed* in the UI of an app. This largely includes:

* "Widgets" - dropdown menus, check boxes, sliders, etc that can be interacted with by the user
* Plots, tables, etc - outputs that are generated with R code
* Navigation aspects of an app - tabs, panes, etc. 
* Generic text, hyperlinks, etc
* HTML and CSS elements (addressed later)

The most important thing to understand about the UI is that it *receives inputs* from the user and *displays outputs* from the server. There is no *active* code running in the ui *at any time* - all changes seen in the UI are passed through the server (more or less). So we have to make our plots, downloads, etc in the server

The server of the shiny app is where all code is being run once the app starts up. The way this works is a little confusing. The server function will effectively _react_ to the user interfacing with the UI, and run chunks of code in response. If things change in the server, these will be passed back up to the ui, where the changes can be seen. Importantly, the code in the server will be executed *non-consecutively* (or it's best to think of it this way). Basically, whenever a ui input affects a chunk of code in the server, it will run automatically, and the output will be produced.

This all probably sounds very abstract for now, so we'll have to dive into some examples to get a clear idea of how this actually works. 


### Before you start to build an app

Before you begin to build an app, its immensely helpful to know *what* you want to build. Since your UI will be written in code, you can't really visualise what you're building unless you are aiming for something specific. For this reason, it is immensely helpful to look at lots of examples of shiny apps to get an idea of what you can make - even better if you can look at the source code behind these apps! Some great resources for this are:

- [Rstudio app gallery](https://shiny.rstudio.com/gallery/)
- 

Once you get an idea for what is possible, it's also helpful to map out what you want yours to look like - you can do this in any drawing software (PowerPoint, MS paint, etc.). It's helpful to start simple for your first app! There's also no shame in using code you find online of a nice app as a template for your work - its much easier than building something from scratch!



## Building a UI 

When building our app, its easier to work on the UI first so we can see what we're making, and not risk the app failing because of any server errors. As mentioned previously, its often good to use a template when working on the UI. There are a number of standard layouts that can be used with shiny that are available from the base shiny package, but it's worth noting that there are also a number of package extensions such as `shinydashboard`. We'll use an example from base shiny to start with. 

A shiny UI is generally defined as a series of nested functions, in the following order

1. A function defining the general layout (the most basic is `fluidPage()`, but more are available)
2. Panels within the layout such as:
     - a sidebar (`sidebarPanel()`)
     - a "main" panel (`mainPanel()`)
     - a tab (`tabPanel()`)
     - a generic "column" (`column()`)
3. Widgets and outputs - these can confer inputs to the server (widgets) or outputs from the server (outputs)
     - Widgets generally are styled as `xxxInput()` e.g. `selectInput()`
     - Outputs are generally styled as `xxxOutput()` e.g. `plotOutput()`

It's worth stating again that these can't be visualised easily in an abstract way, so it's best to look at an example! Lets consider making a basic app that visualises our malaria facility count data by district. This data has a lot of differnet parameters, so it would be great if the end user could apply some filters to see the data by age group/district as they see fit! We can use a very simple shiny layout to start - the sidebar layout. This is a layout where widgets are placed in a sidebar on the left, and the plot is placed on the right.

Lets plan our app - we can start with a selector that lets us choose the district where we want to visualise data, and another to let us visualise the age group we are interested in. We'll aim to use these filters to show an epicurve that reflects these parameters. So for this we need:

1. Two dropdown menus that let us choose the district we want, and the age group we're interested in. 
2. An area where we can show our resulting epicurve.

This might look something like this:

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = TRUE
         ),

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```


This layout looks something like this - note that there will be no plot if there is no server to render it, but our inputs are working!



This is a good opportunity to discuss how widgets work - note that each widget is accepting an `inputId`, a `label`, and a series of other options that are specific to the widget type. This `inputId` is extremely important - these are the IDs that are used to pass information from the UI to the server. For this reason, they *must be unique*. You should make an effort to name them something sensible, and specific to what they are interacting with in cases of larger apps.

You should read documentation carefully for full details on what each of these widgets do. Widgets will pass specific types of data to the server depending on the widget type, and this needs to be fully understood. For example, `selectInput()` will pass a character type to the server:

- If we select _Spring_ for the first widget here, it will pass the character object `"Spring"` to the server. 
- If we select two items from the dropdown menu, they will come through as a vector (e.g. `c("Spring", "Bolo")`).

Other widgets will pass different types of object to the server! For example:

- `numericInput()` will pass a numeric type object to the server
- `checkboxInput()` will pass a logical type object to the server

It's also worth noting the named vector used for the age data here. For many widgets, using a named vector as the choices will display the names of the objects, but pass the contents of the vector to the server. I.e. here we can select _15+_ and it will pass `"malaria_rdt_15"` to the server - which happens to be the name of the column we're interested in!


There are loads of widgets that you can use to do lots of things with your app. Widgets also allow you to upload files into your app, and download outputs. There are also some excellent shiny extensions that give you access to more widgets than base shiny - `shinyWidgets` is a great example of this. To look at some examples you can look at the following links:

- [base shiny widget gallery](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets gallery](https://github.com/dreamRs/shinyWidgets)


