
# ggplot temelleri {}

```{r, out.width=c('100%', '100%'), fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "ggplot_basics_top.png"))
```

**ggplot2** en popüler veri görselleştirme R paketidir. `ggplot()` fonksiyonu bu paketin merkezindedir ve tüm bu yaklaşım akademik camiada *"ggplot"* olarak; ortaya çıkan grafikler de sevgi dolu bir ifade ile "ggplots" olarak adlandırılır. Bu isimlerdeki "gg", şekilleri oluşturmak için kullanılan "**g**rammar of **g**raphics" (grafiklerin grameri) kalıbının kısaltmasıdır. **ggplot2**, işlevselliğini daha da artıran pek çok tamamlayıcı R paketlerinden yararlanmaktadır.

Sözdizimi, R tabanındaki fonksiyon ve komutlardan önemli ölçüde farklıdır ve öğrenmesi de bununla ilişkili olarak daha zordur. **ggplot2** fonksiyonlarını doğru kullanabilmek için genellikle, kullanıcılar verilerini, **tidyverse**e yüksek düzeyde uyumlu bir şekilde biçimlendirmek gerekir, bu da pek çok paketi birlikte kullanmayı zorunlu kılar.

Bu sayfada **ggplot2** ile çizim yapmanın temellerini ele alacağız. Planlarınızın gerçekten güzel görünmesini sağlayacak öneriler ve gelişmiş teknikler için [ggplot ipuçları] sayfasına bakabilirsiniz.

Kaynaklar bölümünde bağlantılı birkaç kapsamlı **ggplot2** rehberi bulabilirsiniz. Ayrıca RStudio web sitesinden [ggplot ile veri görselleştirme kopya kağıdını](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) indirebilirsiniz. Veri görselleştirmelerinizi daha yaratıcı bir şekilde yaparken birkaç ilham almak isterseniz, [R grafiği galerisi](https://www.r-graph-gallery.com/) ve [Data-to-viz](https://www.data-to-viz.com/caveats.html) gibi web sitelerini incelemenizi öneririz.


<!-- ======================================================= -->
## Hazırlık {}

### Paketlerin yüklenmesi {.unnumbered}

Aşağıdaki bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` fonksiyonunu kullanacağız. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  tidyverse,      # ggplot2 ve diğer veri yönetim paketlerini içerir
  rio,            # içe / dışa aktarma
  here,           # dosya lokasyonu bulma
  stringr         # metinle çalışmak için   
)
```

### Verileri içe aktarma {.unnumbered}  

Örnek için Ebola salgınını simüle vakaların veri setini içe aktaracağız. Örneği takip etmek isterseniz, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` işleviyle içe aktarabilirsiniz (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda gösterilmiştir. "age" (yaş), "wt_kg" (kilo cinsinden ağırlık), "ct_blood" (CT değerleri) ve "days_onset_hosp" (başlangıç tarihi ile hastaneye yatış arasındaki fark) sürekli değişkenlerine odaklanacağız.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Genel temizleme {.unnumbered}

Çizilecek verileri hazırlarken, verilerin mümkün olduğunca ["tidy" veri standartlarına](https://r4ds.had.co.nz/tidy-data.html) uygun düzenlemek gerekir. Bunun nasıl yapılacağı, bu el kitabının [Verileri temizleme ve temel işlevler] gibi veri yönetimi sayfalarında ayrıntılı olarak açıklanmıştır.

Verileri çizim için daha iyi hale getirmek için kullanılan bazı basit yollar, verilerin içeriğini görüntüleme için daha iyi hale getirmeyi içerebilir. Bu yolların, veri işlemeyi her zaman daha da kolaylaştıracağı anlamına gelmez. Örneğin:

* Bir karakter sütunundaki `NA` değerlerini "Bilinmeyen" karakter dizesiyle değiştirme  
* Sütunu *faktör* sınıfına çevirerek, değerleri sıralı düzeylere dönüştürme 
* Bazı sütunları, alt çizgi vb. içeren "veri dostu" değerlerinin normal metin veya büyük/küçük harfe dönüştürülmesi (bkz. [Karakterler ve dizeler]) 

İşte bu yolların bazı örnekleri:

```{r, }
# sütunların görüntü sürümünü daha kolay adlara değiştirme
linelist <- linelist %>%
  mutate(
    gender_disp = case_when(gender == "m" ~ "Male",        # m'den Male'e çevirme 
                            gender == "f" ~ "Female",      # f'den Female'e çevirme
                            is.na(gender) ~ "Unknown"),    # NA'dan Unknown'a çevirme
    
    outcome_disp = replace_na(outcome, "Unknown")          # replace NA outcome with "unknown"
  )
```

### Uzun formata döndürme {.unnumbered}

Veri yapısıyla ilgili olarak, **ggplot2** için genellikle verilerimizi *daha uzun* biçimlere döndürmek isteyebiliriz. Bununla ilgili daha fazla bilgiyi [Verilerin Pivotlanması] sayfasında bulabilirsiniz.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

Örneğin, `satır listesi`ndeki her bir vaka ve ilişkili verilerini "geniş" bir biçimde çizmek istediğimizi varsayalım. Aşağıda, yalnızca `case_id` ve semptomların sütunlarını içeren `symptoms_data` adlı bir mini satır listesi oluşturuyoruz.

```{r}
symptoms_data <- linelist %>% 
  select(c(case_id, fever, chills, cough, aches, vomit))
```

Bu mini-satır listesinin ilk 50 satırı aşağıdaki şekilde görünür - her bir semptomun sütunda nasıl "geniş" olarak biçimlendirildiklerini görebilirsiniz:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(symptoms_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Spesifik semptomları olan vakaların sayısını çizmek istersek, her semptomun belirli bir sütunda olması gerçeğiyle sınırlıyız. Ancak, semptom sütunlarını aşağıdaki gibi daha uzun bir biçime *pivot*layabiliriz:

```{r, }
symptoms_data_long <- symptoms_data %>%    # symptoms_data adlı "mini" satır listesiyle başla
  
  pivot_longer(
    cols = -case_id,                       # case_id dışındaki tüm sütunları döndür (tüm belirti sütunları)
    names_to = "symptom_name",             # semptomları içeren yeni sütun için ad ata
    values_to = "symptom_is_present") %>%  # değerleri tutan yeni sütun için ad ata (evet/hayır)
  
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown")) # NA'yı "unknown"a dönüştür

```

İşte ilk 50 satır. Burada vakaların 5 satırı olduğunu unutmayın - her olası semptom için bir tane. Yeni `symptom_name` ve `symptom_is_present` sütunları, pivotlamanın sonucudur. Bu formatın diğer işlemler için çok yararlı olmayabileceğini, ancak çizim için faydalı olduğunu unutmayın.

```{r, message=FALSE, echo=F}
DT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
## ggplot temelleri {}

**"Grafiklerin grameri" - ggplot2**  

**ggplot2** ile çizim, çizim katmanları ve tasarım öğelerinin birbirinin üzerine "eklenmesi" prensibine dayanır. Her komut bir öncekine bir artı sembolü (`+`) ile eklenir. Sonuç, kaydedilebilen, değiştirilebilen, yazdırılabilen, dışa aktarılabilen vb. çok katmanlı bir çizim nesnesidir.

ggplot nesneleri oldukça karmaşık olabilir, ancak katmanların temel sırası genellikle şöyle görünür:

1. Başta temel `ggplot()` komutuyla başlayın - bu, ggplot fonksiyonunu "açar" ve sonraki işlevlerin "+" ile eklenmesine izin verir. Tipik olarak veri kümesi de bu komutta belirtilir.
2. "Geom" katmanlarını ekleyin - bu işlevler verileri *geometriler* (*şekiller*) olarak görselleştirir, ör. çubuk grafik, çizgi grafiği, dağılım grafiği, histogram (veya bir kombinasyon!) olarak. Bu işlevlerin tümü, önek olarak "geom_" ile başlar.
3. Eksen etiketleri, başlık, yazı tipleri, boyutlar, renk şemaları, göstergeler veya eksen dönüşü gibi tasarım öğelerini çizime ekleyin

Basit bir kod dizilim örneği aşağıdaki gibidir. Her bir bileşeni aşağıdaki bölümlerde açıklayacağız.

```{r, eval=F}
# my_data sütunlarındaki verileri kırmızı noktalar olarak çiz
ggplot(data = my_data)+                   # "my_data" veri kümesini kullan
  geom_point(                             # bir nokta katmanı ekle (noktalar)
    mapping = aes(x = col1, y = col2),    # veri sütununu eksene "haritala"
    color = "red")+                       # geom için diğer özellikler
  labs()+                                 # buraya başlıklar, eksen etiketleri vb. eklenir
  theme()                                 # burada veri olmayan çizim öğelerinin (eksenler, başlık vb.) rengi, yazı tipi, boyutu vb. ayarlanır 
```


## `ggplot()`  

Herhangi bir ggplot2 grafiğinin açılış komutu `ggplot()` şeklindedir. Bu komut, üzerine katmanların ekleneceği boş bir arka plan oluşturur. Bir `+` sembolü ile ek katmanların eklenmesinin yolunu "açar".

Tipik olarak, `ggplot()` komutu, çizim için gerekli olan `data =` argümanını içerir. Bu, grafiğin sonraki katmanları için kullanılacak varsayılan veri kümesini ayarlar. 

Bu komut, kapanış parantezlerinden sonra bir `+` ile bitecektir. Bu, komutu "açık" bırakır. ggplot yalnızca, tam komut sonunda bir `+` *olmadan* son bir katman içerdiğinde yürütülür/görünür.

```{r, eval=F}
# Bu komut, boş bir arka planı olan bir grafik yaratacaktır.
ggplot(data = linelist)
```


## Geomlar

Boş bir arka plan kesinlikle yeterli değildir - verilerden (örneğin çubuk grafikler, histogramlar, dağılım grafikleri, kutu grafikleri) geometriler (şekiller) oluşturmanız gerekir.

Grafikler, ilk `ggplot()` komutuna `geom` katmanları eklenerek yapılır. `Geom` oluşturabilen birçok **ggplot2** fonksiyonu mevcuttur. Bu fonksiyonların her biri `geom_` ile başlar, bu nedenle onlardan genel olarak `geom_XXXX()` olarak bahsedeceğiz. **ggplot2**'de gönüllüler tarafından oluşturulmuş 40'tan fazla geoms bulunmaktadır. Bunları [ggplot2 galerisinden](https://exts.ggplot2.tidyverse.org/gallery/) görüntüleyebilirsiniz. Bazı yaygın geomlar aşağıda listelenmiştir:  

* Histogramlar - `geom_histogram()`  
* Çubuk grafikler - `geom_bar()` yada `geom_col()` (["Çubuk grafikleri" bölümüne bakabilirsiniz](#ggplot_basics_bars))  
* Kutu grafiği - `geom_boxplot()`  
* Noktalar (örn. dağılım grafikleri) - `geom_point()`  
* Çizgi grafikler - `geom_line()` yada `geom_path()`  
* Trend eğrileri - `geom_smooth()`  

Bir çizimde bir veya birden fazla geom görüntüleyebilirsiniz. Her biri önceki **ggplot2** komutlarına bir `+' ile eklenir ve sonraki coğrafi konumlar öncekilerin üzerine yerleştirilecek şekilde sırayla çizilir.


## Verileri grafiğe eşleme {#ggplot_basics_mapping}  

Çoğu geom fonksiyonunda şekilleri oluştururken *ne için kullanacakları* söylenmelidir - bu nedenle fonksiyonda *verilerinizdeki sütunları* ilgili grafikle eşleştirerek eksenini, şeklini, rengini, boyutunu vb. tanımlamalısınız. vb. Çoğu grafik konum verileri için, eşlenmesi gereken *temel* bileşenler x ekseni ve (gerekirse) y eksenidir.

Bu "eşleme", `mapping = ` argümanıyla gerçekleşir. `mapping` için sağladığınız eşlemeler `aes()` fonksiyonunda sarılmalıdır, bu nedenle aşağıda gösterildiği gibi `mapping = aes(x = col1, y = col2)` şeklinde yazabilirsiniz.

Aşağıda, `ggplot()` komutunda veriler `linelist` durumu olarak ayarlanır. `mapping = aes()` argümanında `age` sütunu x eksenine, `wt_kg` sütunu ise y eksenine eşlenir.

`+` işaretinden sonra çizim komutları devam eder. `geom` fonksiyonu olan `geom_point()` ile bir şekil oluşturulur. Bu geom, yukarıdaki `ggplot()` komutundan eşlemeleri *devralır* - eksen-sütun atamalarını bilir ve bu ilişkileri alan üzerinde *noktalar* olarak görselleştirmeye devam eder.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
  geom_point()
```

Başka bir örnek olarak, aşağıdaki komutlar aynı verileri, biraz farklı bir eşlemeyi ve farklı bir geom'u kullanır. `geom_histogram()` fonksiyonu, sayımlar y ekseni otomatik olarak oluşturulduğundan, yalnızca x eksenine eşlenmiş bir sütun gerektirir.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()
```


### Grafik estetiği {.unnumbered}  

ggplot terminolojisinde "estetik" konusunun belirli bir anlamı vardır. Burada estetik, *çizilmiş verinin* görsel bir özelliğini ifade eder. Buradaki "estetik" ifadesinin *geomlarda/şekillerde* çizilen verileri de kapsadığını unutmayın - başlıklar, eksen etiketleri, arka plan rengi gibi genel İngilizcede "estetik" kelimesiyle ilişkilendirebileceğiniz çevredeki görüntü değil. ggplot'ta bu ayrıntılara "temalar" denir ve bir `theme()` komutuyla ayarlanır (bkz. [bu bölüm](#ggplot_basics_themes)).

Bu nedenle, çizim nesnesinin *estetiği*, çizilen verilerin renkleri, boyutları, asetatları, yerleşimi vb. olabilir. Tüm geomlar aynı estetik seçeneklere sahip değildir, ancak çoğu geom tarafından kullanılabilir. İşte bazı örnekler: 

* `shape =` Bir noktayı nokta, yıldız, üçgen veya kare olarak `geom_point()` ile gösterme... 
* `fill = ` İç renk (örneğin bir çubuk veya kutu grafiği) 
* `color =` Bir çubuğun, kutu grafiğinin vb. dış çizgisi veya `geom_point()` kullanılıyorsa noktanın rengi
* `size = ` Boyut (ör. çizgi kalınlığı, nokta boyutu) 
* `alpha = ` Şeffaflık (1 = opak, 0 = görünmez)  
* `binwidth = ` Histogram bölmelerinin genişliği 
* `width = ` "Çubuk grafiği" sütunlarının genişliği 
* `linetype =` Çizgi türü (ör. düz, kesikli, noktalı)

Bu çizim nesnesi *estetiğine* değerler iki şekilde atanabilir:

1) Tüm çizilen gözlemlere uygulanacak statik bir değer (ör. ``color = "blue"`) atanması  
2) Her bir gözlemin görüntülenmesi o sütundaki değerine bağlı olacak şekilde bir veri sütununa (ör. `color = hospital`) atanması

<!-- *These non-axis aesthetics can be assigned static values (e.g. `size = 1`) or can be mapped to a column (e.g. `size = age`).* If you want the aesthetic to be assigned a static value, the assignment is placed *outside* the `mapping = aes()`. If you want the aesthetic to be scaled/depend on the value in each row of data, the assignment is made *inside* the `mapping = aes()`.   -->

### Statik bir değer ayarlama {.unnumbered}  

Çizim nesnesine ait estetik değerlerin statik olmasını istiyorsanız, yani - verilerdeki her gözlem için aynı olmasını istiyorsanız, atamasını geom içine, ancak herhangi bir `mapping = aes()` ifadesinin *dışına* yazmalısınız. Bu atamalar `size = 1` veya `color = "blue"` gibi görünebilir. İşte iki örnek:

* İlk örnekte, `mapping = aes()`, `ggplot()` komutunun içindedir ve eksenler, verilerdeki yaş ve ağırlık sütunlarına eşlenir. Çizim estetiğindeki `color = `, `size = ` ve `alpha = `(saydamlık) parametrelerine statik değerler atanır. Anlaşılır olması için, bu, daha sonra çizim estetiği için farklı değerler alacak başka geom'lar ekleyebileceğiniz için 'geom_point()' işlevinde yapılmıştır. 
* İkinci örnekte, histogram yalnızca bir sütuna eşlenen x eksenini gerektirmektedir. `binwidth = `, `color = `, `fill = ` (iç renk) ve `alpha =` parametreleri geom içinde tekrar statik değerlere ayarlanır.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# dağılım grafiği
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # veri ve eksen eşlemesini ayarla
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)         # statik nokta estetiğini ayarla

# histogram
ggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla
  geom_histogram(                # histogramı göster
    binwidth = 7,                # kutuların genişliği
    color = "red",               # sınır çizgi rengi
    fill = "blue",               # kutu iç rengi
    alpha = 0.1)                 # kutu şeffaflığı
```


### SSütun değerlerine ölçekleme {.unnumbered}  

Alternatif olarak, çizim nesnesi estetiğini bir sütundaki değerlerle ölçekleyebiliriz. Bu yaklaşımda, estetiğin görüntüsü, o veri sütunundaki gözlemin değerine bağlı olacaktır. Sütun değerleri sürekli ise, o estetik için görüntü ölçeği de (açıklama) sürekli olacaktır. Sütun değerleri ayrıysa, gösterge her bir değeri görüntüleyecek ve çizilen veriler belirgin bir şekilde "gruplanmış" olarak görünecektirr (bu sayfanın [gruplandırma](#ggplotgroups) bölümünde daha fazlasını okuyabilirsiniz).

Bunu başarmak için, estetiği bir *sütun adına* eşlemeniz gerekmektedir (tırnak içinde değil). Bu eşleme, *`mapping  = aes()` fonksiyonu* içinde yapılmalıdır (not: [aşağıda](##ggplot_basics_map_loc) tartışıldığı gibi kodda bu eşleme atamalarını yapabileceğiniz birkaç yer vardır).

İki örnek aşağıda verilmiştir. 

* İlk örnekte, `color =` parametresi (her noktanın) `age` sütununa eşlenir - açıklamada bir ölçek belirir! Şimdilik ölçeğin var olduğuna dikkat etmeniz yeterlidir- sonraki bölümlerde nasıl değiştirileceğini paylaşcağız. 
* İkinci örnekte, iki yeni çizim estetiği de sütunlarla eşlenir (`color = ` ve `size = `), `shape = ` ve `alpha = ` parametreleri herhangi bir `mapping = aes()` fonksiyonu dışındaki statik değerlere eşlenir.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# dağılım grafiği
ggplot(data = linelist,   # veri ayarla
       mapping = aes(     # estetiği sütun değerlerine eşle
         x = age,           # x eksenini yaşa eşle          
         y = wt_kg,         # y eksenini ağırlıkla eşle
         color = age)
       )+     # yaşa göre rengi eşle
  geom_point()         # verileri nokta olarak göster

# dağılım grafiği
ggplot(data = linelist,   # veri ayarla
       mapping = aes(     # estetiği sütun değerlerine eşle
         x = age,           # x eksenini yaşa eşle           
         y = wt_kg,         # y eksenini ağırlıkla eşle
         color = age,       # yaşa göre rengi eşle
         size = age))+      # yaşa göre boyutu eşle
  geom_point(             # verileri nokta olarak göster
    shape = "diamond",      # noktalar elmas olarak görüntülenir
    alpha = 0.3)            # nokta şeffaflığı 30%


```

Not: Eksen atamaları her zaman verilerdeki sütunlara atanır (statik değerlere değil) ve bu her zaman `mapping = aes()` içinde yapılır.

Daha karmaşık grafikler oluştururken çizim katmanlarınızı ve estetiğinizi takip etmek daha da önemli hale gelir - örneğin birden fazla geom içeren grafikler. Aşağıdaki örnekte, `size = ` parametresi iki kez atanır - bir kez `geom_point()` için ve bir kez de `geom_smooth()` için - her ikisi de statik bir değer olarak.

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(           # estetiği sütunlara eşle
         x = age,
         y = wt_kg,
         color = age_years)
       ) + 
  geom_point(                   # her veri satırı için puan ekle
    size = 1,
    alpha = 0.5) +  
  geom_smooth(                  # trend eğrisi ekle
    method = "lm",              # linear metodla
    size = 2)                   # çizgi boyutunu (çizgi genişliği) 2 yap
```


### Where to make mapping assignments {#ggplot_basics_map_loc .unnumbered}


Aesthetic mapping within `mapping = aes()` can be written in several places in your plotting commands and can even be written more than once. This can be written in the top `ggplot()` command, and/or for each individual geom beneath. The nuances include:  

* Mapping assignments made in the top `ggplot()` command will be inherited as defaults across any geom below, like how `x = ` and `y = ` are inherited 
* Mapping assignments made within one geom apply only to that geom  

Likewise, `data = ` specified in the top `ggplot()` will apply by default to any geom below, but you could also specify data for each geom (but this is more difficult).  

Thus, each of the following commands will create the same plot:  

```{r, eval=F, warning=F, message=F}
# These commands will produce the exact same plot
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()

ggplot(data = linelist)+
  geom_histogram(mapping = aes(x = age))

ggplot()+
  geom_histogram(data = linelist, mapping = aes(x = age))
```




### Groups {#ggplotgroups .unnumbered}  

You can easily group the data and "plot by group". In fact, you have already done this!  

Assign the "grouping" column to the appropriate plot aesthetic, within a `mapping = aes()`. Above, we demonstrated this using continuous values when we assigned point `size = ` to the column `age`. However this works the same way for discrete/categorical columns.  

For example, if you want points to be displayed by gender, you would set `mapping = aes(color = gender)`. A legend automatically appears. This assignment can be made within the `mapping = aes()` in the top `ggplot()` command (and be inherited by the geom), or it could be set in a separate `mapping = aes()` within the geom. Both approaches are shown below:  


```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = gender))+
  geom_point(alpha = 0.5)
```


```{r, eval=F}
# This alternative code produces the same plot
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg))+
  geom_point(
    mapping = aes(color = gender),
    alpha = 0.5)

```


Note that depending on the geom, you will need to use different arguments to group the data. For `geom_point()` you will most likely use `color =`, `shape = ` or `size = `. Whereas for `geom_bar()` you are more likely to use `fill = `. This just depends on the geom and what plot aesthetic you want to reflect the groupings.  

For your information - the most basic way of grouping the data is by using only the `group = ` argument within `mapping = aes()`. However, this by itself will not change the colors, fill, or shapes. Nor will it create a legend. Yet the data are grouped, so statistical displays may be affected.  

To adjust the order of groups in a plot, see the [ggplot tips] page or the page on [Factors]. There are many examples of grouped plots in the sections below on plotting continuous and categorical data.   



## Facets / Small-multiples {#ggplot_basics_facet}  

Facets, or "small-multiples", are used to split one plot into a multi-panel figure, with one panel ("facet") per group of data. The same type of plot is created multiple times, each one using a sub-group of the same dataset.  

Faceting is a functionality that comes with **ggplot2**, so the legends and axes of the facet "panels" are automatically aligned. There are other packages discussed in the [ggplot tips] page that are used to combine completely different plots (**cowplot** and **patchwork**) into one figure.  

Faceting is done with one of the following **ggplot2** functions:

  1. `facet_wrap()` To show a different panel for each level of a *single* variable. One example of this could be showing a different epidemic curve for each hospital in a region. Facets are ordered alphabetically, unless the variable is a factor with other ordering defined.  
  + You can invoke certain options to determine the layout of the facets, e.g. `nrow = 1` or `ncol = 1` to control the number of rows or columns that the faceted plots are arranged within.  
  
  2. `facet_grid()` This is used when you want to bring a second variable into the faceting arrangement. Here each panel of a grid shows the intersection between values in *two columns*. For example, epidemic curves for each hospital-age group combination with hospitals along the top (columns) and age groups along the sides (rows).  
  + `nrow` and `ncol` are not relevant, as the subgroups are presented in a grid  

Each of these functions accept a formula syntax to specify the column(s) for faceting. Both accept up to two columns, one on each side of a tilde `~`.  

* For `facet_wrap()` most often you will write only one column preceded by a tilde `~` like `facet_wrap(~hospital)`. However you can write two columns `facet_wrap(outcome ~ hospital)` - each unique combination will display in a separate panel, but they will not be arranged in a grid. The headings will show combined terms and these won't be specific logic to the columns vs. rows.  If you are providing only one faceting variable, a period `.` is used as a placeholder on the other side of the formula - see the code examples.  

* For `facet_grid()` you can also specify one or two columns to the formula (grid `rows ~ columns`). If you only want to specify one, you can place a period `.` on the other side of the tilde like `facet_grid(. ~ hospital)` or `facet_grid(hospital ~ .)`.  

Facets can quickly contain an overwhelming amount of information - its good to ensure you don't have too many levels of each variable that you choose to facet by. Here are some quick examples with the malaria dataset (see [Download handbook and data]) which consists of daily case counts of malaria for facilities, by age group.  

Below we import and do some quick modifications for simplicity:  

```{r, , warning=F, message=F}
# These data are daily counts of malaria cases, by facility-day
malaria_data <- import(here("data", "malaria_facility_count_data.rds")) %>%  # import
  select(-submitted_date, -Province, -newid)                                 # remove unneeded columns

```

The first 50 rows of the malaria data are below. Note there is a column `malaria_tot`, but also columns for counts by age group (these will be used in the second, `facet_grid()` example).  

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### `facet_wrap()` {.unnumbered}

For the moment, let's focus on the columns `malaria_tot` and `District`. Ignore the age-specific count columns for now. We will plot epidemic curves with `geom_col()`, which produces a column for each day at the specified y-axis height given in column `malaria_tot` (the data are already daily counts, so we use `geom_col()` - see [the "Bar plot" section below](#ggplot_basics_bars)).  

When we add the command `facet_wrap()`, we specify a tilde and then the column to facet on (`District` in this case). You can place another column on the left side of the tilde, - this will create one facet for each combination - but we recommend you do this with `facet_grid()` instead. In this use case, one facet is created for each unique value of `District`.  

```{r, warning=F, message=F}
# A plot with facets by district
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # plot the count data as columns
  theme_minimal()+                              # simplify the background panels
  labs(                                         # add plot labels, title, etc.
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district") +
  facet_wrap(~District)                       # the facets are created
```

### `facet_grid()` {.unnumbered}  

We can use a `facet_grid()` approach to cross two variables. Let's say we want to cross `District` and age. Well, we need to do some data transformations on the age columns to get these data into ggplot-preferred "long" format. The age groups all have their own columns - we want them in a single column called `age_group` and another called `num_cases`. See the page on [Pivoting data] for more information on this process.  

```{r, message=F, warning=F}
malaria_age <- malaria_data %>%
  select(-malaria_tot) %>% 
  pivot_longer(
    cols = c(starts_with("malaria_rdt_")),  # choose columns to pivot longer
    names_to = "age_group",      # column names become age group
    values_to = "num_cases"      # values to a single column (num_cases)
  ) %>%
  mutate(
    age_group = str_replace(age_group, "malaria_rdt_", ""),
    age_group = forcats::fct_relevel(age_group, "5-14", after = 1))
```

Now the first 50 rows of data look like this:  

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_age, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


When you pass the two variables to `facet_grid()`, easiest is to use formula notation (e.g. `x ~ y`) where x is rows and y is columns. Here is the plot, using `facet_grid()` to show the plots for each combination of the columns `age_group` and `District`.

```{r, message=F, warning=F}
ggplot(malaria_age, aes(x = data_date, y = num_cases)) +
  geom_col(fill = "darkred", width = 1) +
  theme_minimal()+
  labs(
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district and age group"
  ) +
  facet_grid(District ~ age_group)
```

### Free or fixed axes {.unnumbered}  

The axes scales displayed when faceting are by default the same (fixed) across all the facets. This is helpful for cross-comparison, but not always appropriate.  

When using `facet_wrap()` or `facet_grid()`, we can add `scales = "free_y"` to "free" or release the y-axes of the panels to scale appropriately to their data subset. This is particularly useful if the actual counts are small for one of the subcategories and trends are otherwise hard to see. Instead of "free_y" we can also write "free_x" to do the same for the x-axis (e.g. for dates) or "free" for both axes. Note that in `facet_grid`, the y scales will be the same for facets in the same row, and the x scales will be the same for facets in the same column.

When using `facet_grid` only, we can add `space = "free_y"` or `space = "free_x"` so that the actual height or width of the facet is weighted to the values of the figure within. This only works if `scales = "free"` (y or x) is already applied. 

```{r, message=FALSE, warning=FALSE}

# Free y-axis
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # plot the count data as columns
  theme_minimal()+                              # simplify the background panels
  labs(                                         # add plot labels, title, etc.
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district - 'free' x and y axes") +
  facet_wrap(~District, scales = "free")        # the facets are created
```


<!-- ```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')} -->
<!-- # A) Facet hospitalsation date by hospital, free y axis -->
<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->
<!--        aes(x = date_hospitalisation ))+ -->
<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->
<!--   labs(title = "A) Histogram with free y axis scales")+ -->
<!--   facet_grid(hospital~., # Facet with hospital as the row  -->
<!--              scales = "free_y") # Free the y scale of each facet -->

<!-- # B) Facet hospitalisation date by hospital, free y axis and vertical spacing -->
<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->
<!--        aes(x = date_hospitalisation ))+ -->
<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->
<!--   labs(title = "B) Histogram with free y axis scales and spacing")+ -->
<!--   facet_grid(hospital~., # Facet with hospital as the row  -->
<!--              scales = "free_y", # Free the y scale of each facet -->
<!--              space = "free_y") # Free the vertical spacing of each facet to optimise space -->

<!-- ``` -->

### Factor level order in facets {.unnumbered}  

See this [post](https://juliasilge.com/blog/reorder-within/) on how to re-order factor levels *within* facets.  


## Storing plots  

### Saving plots {.unnumbered}

By default when you run a `ggplot()` command, the plot will be printed to the Plots RStudio pane. However, you can also save the plot as an object by using the assignment operator `<-` and giving it a name. Then it will not print unless the object name itself is run. You can also print it by wrapping the plot name with `print()`, but this is only necessary in certain circumstances such as if the plot is created inside a *for loop* used to print multiple plots at once (see [Iteration, loops, and lists] page).  

```{r, warning=F, message=F}
# define plot
age_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+
  geom_point(alpha = 0.1)

# print
age_by_wt    
```


### Modifying saved plots {.unnumbered}  

One nice thing about **ggplot2** is that you can define a plot (as above), and then add layers to it starting with its name. You do not have to repeat all the commands that created the original plot! 

For example, to modify the plot `age_by_wt` that was defined above, to include a vertical line at age 50, we would just add a `+` and begin adding additional layers to the plot.  

```{r, warning=F, message=F}
age_by_wt+
  geom_vline(xintercept = 50)
```


### Exporting plots {.unnumbered}   

Exporting ggplots is made easy with the `ggsave()` function from **ggplot2**. It can work in two ways, either:  

* Specify the name of the plot object, then the file path and name with extension  
  * For example: `ggsave(my_plot, here("plots", "my_plot.png"))`  
* Run the command with only a file path, to save the last plot that was printed  
  * For example: `ggsave(here("plots", "my_plot.png"))`  
  
You can export as png, pdf, jpeg, tiff, bmp, svg, or several other file types, by specifying the file extension in the file path.  

You can also specify the arguments `width = `, `height = `, and `units = ` (either "in", "cm", or "mm"). You can also specify `dpi = ` with a number for plot resolution (e.g. 300). See the function details by entering `?ggsave` or reading the [documentation online](https://ggplot2.tidyverse.org/reference/ggsave.html). 

Remember that you can use `here()` syntax to provide the desired file path. See the [Import and export] page for more information.  


## Labels 

Surely you will want to add or adjust the plot's labels. These are most easily done within the `labs()` function which is added to the plot with `+` just as the geoms were.  

Within `labs()` you can provide character strings to these arguements:  

* `x = ` and `y = ` The x-axis and y-axis title (labels)  
* `title = ` The main plot title  
* `subtitle = ` The subtitle of the plot, in smaller text below the title  
* `caption = ` The caption of the plot, in bottom-right by default  

Here is a plot we made earlier, but with nicer labels:  

```{r, warning=F, message=F}
age_by_wt <- ggplot(
  data = linelist,   # set data
  mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age))+     # map color to age
  geom_point()+           # display data as points
  labs(
    title = "Age and weight distribution",
    subtitle = "Fictional Ebola outbreak, 2014",
    x = "Age in years",
    y = "Weight in kilos",
    color = "Age",
    caption = stringr::str_glue("Data as of {max(linelist$date_hospitalisation, na.rm=T)}"))

age_by_wt
```

Note how in the caption assignment we used `str_glue()` from the **stringr** package to implant dynamic R code within the string text. The caption will show the "Data as of: " date that reflects the maximum hospitalization date in the linelist. Read more about this in the page on [Characters and strings].  

A note on specifying the *legend* title: There is no one "legend title" argument, as you could have multiple scales in your legend. Within `labs()`, you can write the argument for the plot aesthetic used to create the legend, and provide the title this way. For example, above we assigned `color = age` to create the legend. Therefore, we provide `color = ` to `labs()` and assign the legend title desired ("Age" with capital A). If you create the legend with `aes(fill = COLUMN)`, then in `labs()` you would write `fill = ` to adjust the title of that legend. The section on color scales in the [ggplot tips] page provides more details on editing legends, and an alternative approach using `scales_()` functions.  



## Themes {#ggplot_basics_themes} 

One of the best parts of **ggplot2** is the amount of control you have over the plot - you can define anything! As mentioned above, the design of the plot that is *not* related to the data shapes/geometries are adjusted within the `theme()` function. For example, the plot background color, presence/absence of gridlines, and the font/size/color/alignment of text (titles, subtitles, captions, axis text...). These adjustments can be done in one of two ways:  

* Add a [*complete theme*](https://ggplot2.tidyverse.org/reference/ggtheme.html) `theme_()` function to make sweeping adjustments - these include `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()` among others  
* Adjust each tiny aspect of the plot individually within `theme()`  


### Complete themes {.unnumbered}  

As they are quite straight-forward, we will demonstrate the complete theme functions below and will not describe them further here. Note that any micro-adjustments with `theme()` should be made *after* use of a complete theme.  

Write them with empty parentheses.  

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme classic")+
  theme_classic()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme bw")+
  theme_bw()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme minimal")+
  theme_minimal()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme gray")+
  theme_gray()
  


```

### Modify theme {.unnumbered}  

The `theme()` function can take a large number of arguments, each of which edits a very specific aspect of the plot. There is no way we could cover all of the arguments, but we will describe the general pattern for them and show you how to find the argument name that you need. The basic syntax is this:

1. Within `theme()` write the argument name for the plot element you want to edit, like `plot.title = `  
3. Provide an `element_()` function to the argument  
  + Most often, use `element_text()`, but others include `element_rect()` for canvas background colors, or `element_blank()` to remove plot elements  
4. Within the `element_()` function, write argument assignments to make the fine adjustments you desire  

So, that description was quite abstract, so here are some examples.  

The below plot looks quite silly, but it serves to show you a variety of the ways you can adjust your plot.  

* We begin with the plot `age_by_wt` defined just above and add `theme_classic()`  
* For finer adjustments we add `theme()` and include one argument for each plot element to adjust  

It can be nice to organize the arguments in logical sections. To describe just some of those used below:  

* `legend.position = ` is unique in that it accepts simple values like "bottom", "top", "left", and "right". But generally, text-related arguments require that you place the details *within* `element_text()`.  
* Title size with `element_text(size = 30)`  
* The caption horizontal alignment with `element_text(hjust = 0)` (from right to left)  
* The subtitle is italicized with `element_text(face = "italic")`  

```{r, , warning=F, message=F}
age_by_wt + 
  theme_classic()+                                 # pre-defined theme adjustments
  theme(
    legend.position = "bottom",                    # move legend to bottom
    
    plot.title = element_text(size = 30),          # size of title to 30
    plot.caption = element_text(hjust = 0),        # left-align caption
    plot.subtitle = element_text(face = "italic"), # italicize subtitle
    
    axis.text.x = element_text(color = "red", size = 15, angle = 90), # adjusts only x-axis text
    axis.text.y = element_text(size = 15),         # adjusts only y-axis text
    
    axis.title = element_text(size = 20)           # adjusts both axes titles
    )     
```

Here are some especially common `theme()` arguments. You will recognize some patterns, such as appending `.x` or `.y` to apply the change only to one axis.  


`theme()` argument                 |What it adjusts
-----------------------------------|----------------------------------
`plot.title = element_text()`      |The title
`plot.subtitle = element_text()`   |The subtitle
`plot.caption = element_text()`    |The caption (family, face, color, size, angle, vjust, hjust...) 
`axis.title = element_text()`      |Axis titles (both x and y) (size, face, angle, color...)
`axis.title.x = element_text()`    |Axis title x-axis only (use `.y` for y-axis only)
`axis.text = element_text()`       |Axis text (both x and y)
`axis.text.x = element_text()`     |Axis text x-axis only (use `.y` for y-axis only)  
`axis.ticks = element_blank()`     |Remove axis ticks
`axis.line = element_line()`       |Axis lines (colour, size, linetype: solid dashed dotted etc)
`strip.text = element_text()`      |Facet strip text (colour, face, size, angle...)
`strip.background = element_rect()`|facet strip (fill, colour, size...)  

But there are so many theme arguments! How could I remember them all? Do not worry - it is impossible to remember them all. Luckily there are a few tools to help you:  

The **tidyverse** documentation on [modifying theme](https://ggplot2.tidyverse.org/reference/theme.html), which has a complete list.  

<span style="color: darkgreen;">**_TIP:_** Run `theme_get()` from **ggplot2** to print a list of all 90+ `theme()` arguments to the console.</span>  

<span style="color: darkgreen;">**_TIP:_** If you ever want to remove an element of a plot, you can also do it through `theme()`. Just pass `element_blank()` to an argument to have it disappear completely. For legends, set `legend.position = "none".`</span>  




## Colors  


Please see this [section on color scales of the ggplot tips page](#ggplot_tips_colors).  



## Piping into **ggplot2**   

When using pipes to clean and transform your data, it is easy to pass the transformed data into `ggplot()`.  

The pipes that pass the dataset from function-to-function will transition to `+` once the `ggplot()` function is called. Note that in this case, there is no need to specify the `data = ` argument, as this is automatically defined as the piped-in dataset.  

This is how that might look:  

```{r, warning=F, message=F}
linelist %>%                                                     # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )
```









## Plot continuous data

Throughout this page, you have already seen many examples of plotting continuous data. Here we briefly consolidate these and present a few variations.  
Visualisations covered here include:

* Plots for one continuous variable:  
  * **Histogram**, a classic graph to present the distribution of a continuous variable. 
  * **Box plot** (also called box and whisker), to show the 25th, 50th, and 75th percentiles, tail ends of the distribution, and outliers ([important limitations](https://www.data-to-viz.com/caveat/boxplot.html)).  
  * **Jitter plot**, to show all values as points that are 'jittered' so they can (mostly) all be seen, even where two have the same value.  
  * **Violin plot**, show the distribution of a continuous variable based on the symmetrical width of the 'violin'. 
  * **Sina plot**, are a combination of jitter and violin plots, where individual points are shown but in the symmetrical shape of the distribution (via **ggforce** package).  
* **Scatter plot** for two continuous variables.  
* **Heat plots** for three continuous variables (linked to [Heat plots] page)  



### Histograms {.unnumbered}

Histograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the "bars", and only one column is provided to `geom_histogram()`.

Below is code for generating **histograms**, which group continuous data into ranges and display in adjacent bars of varying height. This is done using `geom_histogram()`. See the ["Bar plot" section](#ggplot_basics_bars) of the ggplot basics page to understand difference between `geom_histogram()`, `geom_bar()`, and `geom_col()`.  

We will show the distribution of ages of cases. Within `mapping = aes()` specify which column you want to see the distribution of. You can assign this column to either the x or the y axis. 

The rows will be assigned to "bins" based on their numeric age, and these bins will be graphically represented by bars. If you specify a number of bins with the `bins = ` plot aesthetic, the break points are evenly spaced between the minimum and maximum values of the histogram. If `bins = ` is unspecified, an appropriate number of bins will be guessed and this message displayed after the plot:  

```
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
``` 

If you do not want to specify a number of bins to `bins = `, you could alternatively specify `binwidth = ` in the units of the axis. We give a few examples showing different bins and bin widths:  

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Regular histogram
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram()+
  labs(title = "A) Default histogram (30 bins)")

# B) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 50)+
  labs(title = "B) Set to 50 bins")

# C) Fewer bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 5)+
  labs(title = "C) Set to 5 bins")


# D) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(binwidth = 1)+
  labs(title = "D) binwidth of 1")

```



To get smoothed proportions, you can use `geom_density()`:  

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional density")

# Stacked frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_density(size = 2, alpha = 0.2, position = "stack")+
  labs(title = "'Stacked' proportional densities")
```


To get a "stacked" histogram (of a continuous column of data), you can do one of the following:  

1) Use `geom_histogram()` with the `fill = ` argument within `aes()` and assigned to the grouping column, or  
2) Use `geom_freqpoly()`, which is likely easier to read (you can still set `binwidth = `)  
3) To see proportions of all values, set the `y = after_stat(density)` (use this syntax exactly - not changed for your data). Note: these proportions will show *per group*.  

Each is shown below (*note use of `color = ` vs. `fill = ` in each):  

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# "Stacked" histogram
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_histogram(binwidth = 2)+
  labs(title = "'Stacked' histogram")

# Frequency 
ggplot(data = linelist, mapping = aes(x = age, color = gender)) +
  geom_freqpoly(binwidth = 2, size = 2)+
  labs(title = "Freqpoly")

# Frequency with proportion axis
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +
  geom_freqpoly(binwidth = 5, size = 2)+
  labs(title = "Proportional freqpoly")

# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional, smoothed with geom_density()")
```

If you want to have some fun, try `geom_density_ridges` from the **ggridges** package ([vignette here](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html).  

Read more in detail about histograms at the **tidyverse** [page on geom_histogram()](https://ggplot2.tidyverse.org/reference/geom_histogram.html).  



### Box plots {.unnumbered}

Box plots are common, but have important limitations. They can obscure the actual distribution - e.g. a bi-modal distribution. See this [R graph gallery](https://www.r-graph-gallery.com/boxplot.html) and this [data-to-viz article](https://www.data-to-viz.com/caveat/boxplot.html) for more details. However, they do nicely display the inter-quartile range and outliers - so they can be overlaid on top of other types of plots that show the distribution in more detail.  

Below we remind you of the various components of a boxplot:  

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "boxplot.png"))
```

When using `geom_boxplot()` to create a box plot, you generally map only one axis (x or y) within `aes()`. The axis specified determines if the plots are horizontal or vertical. 

In most geoms, you create a plot per group by mapping an aesthetic like `color = ` or `fill = ` to a column within `aes()`. However, for box plots achieve this by assigning the grouping column to the un-assigned axis (x or y). Below is code for a boxplot of *all* age values in the dataset, and second is code to display one box plot for each (non-missing) gender in the dataset. Note that `NA` (missing) values will appear as a separate box plot unless removed. In this example we also set the `fill` to the column `outcome` so each plot is a different color - but this is not necessary.  

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Overall boxplot
ggplot(data = linelist)+  
  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)
  labs(title = "A) Overall boxplot")

# B) Box plot by group
ggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + 
  geom_boxplot()+                     
  theme(legend.position = "none")+   # remove legend (redundant)
  labs(title = "B) Boxplot by gender")      
```

For code to add a box plot to the edges of a scatter plot ("marginal" plots) see the page [ggplot tips].  





### Violin, jitter, and sina plots {.unnumbered}

Below is code for creating **violin plots** (`geom_violin`) and **jitter plots** (`geom_jitter`) to show distributions. You can specify that the fill or color is also determined by the data, by inserting these options within `aes()`. 

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}


# A) Jitter plot by group
ggplot(data = linelist %>% drop_na(outcome),      # remove missing values
       mapping = aes(y = age,                     # Continuous variable
           x = outcome,                           # Grouping variable
           color = outcome))+                     # Color variable
  geom_jitter()+                                  # Create the violin plot
  labs(title = "A) jitter plot by gender")     



# B) Violin plot by group
ggplot(data = linelist %>% drop_na(outcome),       # remove missing values
       mapping = aes(y = age,                      # Continuous variable
           x = outcome,                            # Grouping variable
           fill = outcome))+                       # fill variable (color)
  geom_violin()+                                   # create the violin plot
  labs(title = "B) violin plot by gender")    
```


You can combine the two using the `geom_sina()` function from the **ggforce** package. The sina plots the jitter points in the shape of the violin plot. When overlaid on the violin plot (adjusting the transparencies) this can be easier to visually interpret.  

```{r, warning=F, message=F}

# A) Sina plot by group
ggplot(
  data = linelist %>% drop_na(outcome), 
  aes(y = age,           # numeric variable
      x = outcome)) +    # group variable
  geom_violin(
    aes(fill = outcome), # fill (color of violin background)
    color = "white",     # white outline
    alpha = 0.2)+        # transparency
  geom_sina(
    size=1,                # Change the size of the jitter
    aes(color = outcome))+ # color (color of dots)
  scale_fill_manual(       # Define fill for violin background by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  scale_color_manual(      # Define colours for points by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  theme_minimal() +                                # Remove the gray background
  theme(legend.position = "none") +                # Remove unnecessary legend
  labs(title = "B) violin and sina plot by gender, with extra formatting")      


```



### Two continuous variables  {.unnumbered}

Following similar syntax, `geom_point()` will allow you to plot two continuous variables against each other in a **scatter plot**. This is useful for showing actual values rather than their distributions. A basic scatter plot of age vs weight is shown in (A). In (B) we again use `facet_grid()` to show the relationship between two continuous variables in the linelist. 

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Basic scatter plot of weight and age
ggplot(data = linelist, 
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "A) Scatter plot of weight and age")

# Scatter plot of weight and age by gender and Ebola outcome
ggplot(data = linelist %>% drop_na(gender, outcome), # filter retains non-missing gender/outcome
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "B) Scatter plot of weight and age faceted by gender and outcome")+
  facet_grid(gender ~ outcome) 

```


### Three continuous variables {.unnumbered}  

You can display three continuous variables by utilizing the `fill = ` argument to create a *heat plot*. The color of each "cell" will reflect the value of the third continuous column of data. See the [ggplot tips] page and the page on on [Heat plots] for more details and several examples. 

There are ways to make 3D plots in R, but for applied epidemiology these are often difficult to interpret and therefore less useful for decision-making.  









## Plot categorical data  

Categorical data can be character values, could be logical (TRUE/FALSE), or factors (see the [Factors] page). 

### Preparation  {.unnumbered}

#### Data structure {.unnumbered}  

The first thing to understand about your categorical data is whether it exists as raw observations like a linelist of cases, or as a summary or aggregate data frame that holds counts or proportions. The state of your data will impact which plotting function you use:  

* If your data are raw observations with one row per observation, you will likely use `geom_bar()`  
* If your data are already aggregated into counts or proportions, you will likely use `geom_col()`  


#### Column class and value ordering {.unnumbered}  

Next, examine the class of the columns you want to plot. We look at `hospital`, first with `class()` from **base** R, and with `tabyl()` from **janitor**.  

```{r}
# View class of hospital column - we can see it is a character
class(linelist$hospital)

# Look at values and proportions within hospital column
linelist %>% 
  tabyl(hospital)
```

We can see the values within are characters, as they are hospital names, and by default they are ordered alphabetically. There are 'other' and 'missing' values, which we would prefer to be the last subcategories when presenting breakdowns. So we change this column into a factor and re-order it. This is covered in more detail in the [Factors] page.

```{r}
# Convert to factor and define level order so "Other" and "Missing" are last
linelist <- linelist %>% 
  mutate(
    hospital = fct_relevel(hospital, 
      "St. Mark's Maternity Hospital (SMMH)",
      "Port Hospital", 
      "Central Hospital",
      "Military Hospital",
      "Other",
      "Missing"))

```


```{r}
levels(linelist$hospital)
```

### `geom_bar()` {#ggplot_basics_bars .unnumbered}  

Use `geom_bar()` if you want bar height (or the height of stacked bar components) to reflect *the number of relevant rows in the data*. These bars will have gaps between them, unless the `width = ` plot aesthetic is adjusted.  

* Provide only one axis column assignment (typically x-axis). If you provide x and y, you will get `Error: stat_count() can only have an x or y aesthetic.`  
* You can create stacked bars by adding a `fill = ` column assignment within `mapping = aes()`  
* The opposite axis will be titled "count" by default, because it represents the number of rows  

Below, we have assigned outcome to the y-axis, but it could just as easily be on the x-axis. If you have longer character values, it can sometimes look better to flip the bars sideways and put the legend on the bottom. This may impact how your factor levels are ordered - in this case we reverse them with `fct_rev()` to put missing and other at the bottom.    

```{r, out.width=c('50%', '50%'), fig.show='hold'}
# A) Outcomes in all cases
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +
  theme_minimal()+
  labs(title = "A) Number of cases by hospital",
       y = "Hospital")


# B) Outcomes in all cases by hosptial
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +
  theme_minimal()+
  theme(legend.position = "bottom") +
  labs(title = "B) Number of recovered and dead Ebola cases, by hospital",
       y = "Hospital")

```





### `geom_col()` {.unnumbered}  

Use `geom_col()` if you want bar height (or height of stacked bar components) to reflect pre-calculated *values* that exists in the data. Often, these are summary or "aggregated" counts, or proportions.  

Provide column assignments for *both* axes to `geom_col()`. Typically your x-axis column is discrete and your y-axis column is numeric. 

Let's say we have this dataset `outcomes`:  

```{r, echo = F}
outcomes <- linelist %>% 
  drop_na() %>% 
  group_by(outcome) %>% 
  count %>% 
  ungroup() %>% # Ungroup so proportion is out of total
  mutate(proportion = n/sum(n)*100) # Caculate percentage
  
outcomes #View full table
```



Below is code using `geom_col` for creating  simple bar charts to show the distribution of Ebola patient outcomes. With geom_col, both x and y need to be specified. Here x is the categorical variable along the x axis, and y is the generated proportions column `proportion`. 

```{r, fig.height = 3, fig.width=4.5}
# Outcomes in all cases
ggplot(outcomes) + 
  geom_col(aes(x=outcome, y = proportion)) +
  labs(subtitle = "Number of recovered and dead Ebola cases")

```

To show breakdowns by hospital, we would need our table to contain more information, and to be in "long" format. We create this table with the frequencies of the combined categories `outcome` and `hospital` (see [Grouping data] page for grouping tips). 

```{r, fig.height = 4, fig.width=6}
outcomes2 <- linelist %>% 
  drop_na(outcome) %>% 
  count(hospital, outcome) %>%  # get counts by hospital and outcome
  group_by(hospital) %>%        # Group so proportions are out of hospital total
  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total

head(outcomes2) # Preview data
```

We then create the ggplot with some added formatting:

  * **Axis flip**: Swapped the axis around with `coord_flip()` so that we can read the hospital names.
  * **Columns side-by-side**: Added a `position = "dodge"` argument so that the bars for death and recover are presented side by side rather than stacked. Note stacked bars are the default.
  * **Column width**: Specified 'width', so the columns are half as thin as the full possible width.
  * **Column order**: Reversed the order of the categories on the y axis so that 'Other' and 'Missing' are at the bottom, with `scale_x_discrete(limits=rev)`. Note that we used that rather than `scale_y_discrete` because hospital is stated in the `x` argument of `aes()`, even if visually it is on the y axis. We do this because Ggplot seems to present categories backwards unless we tell it not to.  
  * **Other details**: Labels/titles and colours added within `labs` and `scale_fill_color` respectively.
  
```{r, fig.height = 4, fig.width=8}

# Outcomes in all cases by hospital
ggplot(outcomes2) +  
  geom_col(
    mapping = aes(
      x = proportion,                 # show pre-calculated proportion values
      y = fct_rev(hospital),          # reverse level order so missing/other at bottom
      fill = outcome),                # stacked by outcome
    width = 0.5)+                    # thinner bars (out of 1)
  theme_minimal() +                  # Minimal theme 
  theme(legend.position = "bottom")+
  labs(subtitle = "Number of recovered and dead Ebola cases, by hospital",
       fill = "Outcome",             # legend title
       y = "Count",                  # y axis title
       x = "Hospital of admission")+ # x axis title
  scale_fill_manual(                 # adding colors manually
    values = c("Death"= "#3B1c8C",
               "Recover" = "#21908D" )) 

```


Note that the proportions are binary, so we may prefer to drop 'recover' and just show the proportion who died. This is just for illustration purposes.  


If using `geom_col()` with dates data (e.g. an epicurve from aggregated data) - you will want to adjust the `width = ` argument to remove the "gap" lines between the bars. If using daily data set `width = 1`. If weekly, `width = 7`. Months are not possible because each month has a different number of days.  


### `geom_histogram()` {.unnumbered}  

Histograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the "bars", and only one column is provided to `geom_histogram()`. There are arguments specific to histograms such as `bin_width = ` and `breaks = ` to specify how the data should be binned. The section above on continuous data and the page on [Epidemic curves] provide additional detail.  



## Resources  

There is a huge amount of help online, especially with ggplot. See:

* [ggplot2 cheat sheet](http://r-statistics.co/ggplot2-cheatsheet.html)
* [another cheat sheet](https://biostats.w.uib.no/the-ggplot2-cheat-sheet-by-rstudio/)
* [tidyverse ggplot basics page](https://ggplot2.tidyverse.org/reference/)  
* [plotting continuous variables](http://www.sthda.com/english/articles/32-r-graphics-essentials/131-plot-two-continuous-variables-scatter-graph-and-alternatives/)  
* R for Data Science pages on [data visualization](https://r4ds.had.co.nz/data-visualisation.html)
* [graphics for communicaton](https://r4ds.had.co.nz/graphics-for-communication.html)  

